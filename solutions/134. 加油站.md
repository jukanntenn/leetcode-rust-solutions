# 加油站

## 描述

> 来源：力扣（LeetCode）
>
> 链接：<https://leetcode.cn/problems/gas-station/>

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

**示例 1:**

> **输入:** gas = [1,2,3,4,5], cost = [3,4,5,1,2]  
> **输出:** 3  
> **解释:**  
> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> 因此，3 可为起始索引。

**示例 2:**

> **输入:** gas = [2,3,4], cost = [3,4,3]  
> **输出:** -1  
> **解释:**
> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
> 因此，无论怎样，你都不可能绕环路行驶一周。

**提示:**

- `gas.length == n`
- `cost.length == n`
- `1 <= n <= 105`
- `0 <= gas[i], cost[i] <= 104`

## 题解

### 方法一：一次遍历

使用双指针的思想，设定两个指针 `i` 和 `j`，先让 `j` 尽可能地往后走，如果 `j` 能回到 `i`，说明从 `i` 出发能绕环路行驶一周。否则 `j` 将停在中间某个站点不能再继续前进，此时将 `i` 逐个往后尝试，看新的起点站 `i` 能否到达 `j`。

官解给出了一个重要的结论：若从 `i` 出发最远能到达 `j`，则从 `i` 往后至包括 `j` 在内的站点作为起点站，均不可能绕环路行驶一周。

官解使用不等式的缩放来证明此结论，比较晦涩。[详细通俗的思路分析，多解法][1] 中给出了一种反证法，更容易理解，大家可以参考一下：

> 当考虑 i 能到达的最远的时候，假设是 j。
> 那么 i + 1 到 j 之间的节点是不是就都不可能绕一圈了？
> 假设 i + 1 的节点能绕一圈，那么就意味着从 i + 1 开始一定能到达 j + 1。
> 又因为从 i 能到达 i + 1，所以从 i 也能到达 j + 1。
> 但事实上，i 最远到达 j 。产生矛盾，所以 i + 1 的节点一定不能绕一圈。同理，其他的也是一样的证明。

这个结论能帮助我们跳过很多不必要的尝试。当然解题的时候不一定能想到这个结论，即使没有这个结论，我们将 `i+1` 到 `j` 的站点都尝试一遍也并不会影响总体的时间复杂度。下面的代码是不使用该结论的解法，逻辑更加直观，时间复杂度仍为 $O(n)$。

```rust
impl Solution {
    pub fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 {
        let n = gas.len();
        let mut i = 0;
        let mut j = 0;

        let mut remaining = 0;

        loop {
            // 先尝试往下一站走，看看能剩多少油
            remaining += gas[j];
            remaining -= cost[j];
            j = (j + 1) % n;

            // 剩的油 >= 0，说明能够走到下一站
            if remaining >= 0 {
                // 下一站就是出发的站，返回结果，否则继续往下一站走
                if j == i {
                    return i as i32;
                }
                continue;
            }

            // 剩的油 < 0，不断尝试将 i 后面的站作为起点站，看能不能到达 j。
            // 最多尝试到站点 j，因为尝试到站点 j 时 remaining = 0，循环将退出。
            // 当然根据理论分析，一定会尝试到站点 j。
            while remaining < 0 {
                remaining -= gas[i];
                remaining += cost[i];

                i = (i + 1) % n;
                // 试完了所有起点站都没能成功行驶一周，返回 -1
                if i == 0 {
                    return -1;
                }
            }
        }

        unreachable!();
    }
}
```

[1]: https://leetcode.cn/problems/gas-station/solutions/25644/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--30/?envType=study-plan-v2&envId=top-interview-150
