# 颠倒二进制位

## 描述

> 来源：力扣（LeetCode）
>
> 链接：<https://leetcode.cn/problems/reverse-bits/>

颠倒给定的 32 位无符号整数的二进制位。

**提示：**

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/二进制补码/5295284)记法来表示有符号整数。因此，在 **示例 2** 中，输入表示有符号整数 `-3`，输出表示有符号整数 `-1073741825`。

**示例 1：**

> **输入**：n = 00000010100101000001111010011100  
> **输出**：964176192 (00111001011110000010100101000000)  
> **解释**：输入的二进制串 **00000010100101000001111010011100** 表示无符号整数 **43261596**，因此返回 964176192，其二进制表示形式为 **00111001011110000010100101000000**。

**示例 2：**

> **输入**：n = 11111111111111111111111111111101  
> **输出**：3221225471 (10111111111111111111111111111111)  
> **解释**：输入的二进制串 **11111111111111111111111111111101** 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 **10111111111111111111111111111111**。

**提示：**

- 输入是一个长度为 `32` 的二进制字符串

**进阶**: 如果多次调用这个函数，你将如何优化你的算法？

## 方法一：逐位颠倒

总体思路 [官方题解][1] 已经讲解的很清晰，这里补充说明几个位操作的效果：

- `n & 1` 得到 n 的最低位。
- `(n & 1) << (31 - i)` 即将 n 的最低位移到点到后对应的位置。
- `rev |= (n & 1) << (31 - i)` 将对应位置的值写到 rev。

```rust
impl Solution {
    pub fn reverse_bits(x: u32) -> u32 {
        let mut n = x;
        let mut rev: u32 = 0;

        for i in 0..32 {
            if n == 0 {
                break;
            }

            rev |= (n & 1) << (31 - i);
            n >>= 1;
        }

        rev
    }
}
```

## 方法二：位运算分治

[官方题解][1] 在思路讲解时使用自上而下的分治法，但代码实现上又使用自下而上的分治，反而不容易理解。这里我们思路讲解和代码实现保持一致，均使用自上而下的分治。

若要颠倒一个二进制串，可以将其均分成左右两部分，将左右两部分交换位置，再分别颠倒左右两部分。即定义 $R$ 为颠倒二进制串的操作，则 $R(XY)=R(Y)R(X)$。

由于只需要颠倒一个 32 位的二进制串，操作步骤是有限的，我们可以枚举每一步的操作，不需要写递归的代码。

先来看第一步，需要分别交换左右 16 位，这个很好办，只需要将左边的 16 位右移 16 位，将右边的 16 位左移 16 位，再合并到一起即可，也就是：

```rust
n = n >> 16 | n << 16
```

接下来看第二步，左边 16 位需要分别交换这 16 位的左右 8 位；右边 16 位也是一样。为了方便表述，假设 32 位数字具有如下形式，每个符号占 4 位，整个交换过程可表示为：

```txt
// @@@@ 和 #### 交换；$$$$ 和 %%%% 交换
@@@@####$$$$%%%% -> ####@@@@%%%%$$$$
```

而最终的结果 `####@@@@%%%%$$$$` 可以看做 `0000@@@@0000$$$$ | ####0000%%%%0000`。分解开来就是 `@@@@####$$$$%%%%` 变成 `@@@@0000$$$$0000` 再左移 8 位变成 `0000@@@@0000$$$$`；`@@@@####$$$$%%%%` 变成 `0000####0000%%%%` 再右移 8 位变成 `####0000%%%%0000`，再将两个串合并到一起，也就是：

```rust
n = (n & 0xff00ff00) >> 8 | (n & 0x00ff00ff) << 8
```

依次类推，得到下面的代码（代码中用到的魔法常数，如果不是很明白的话将其转为二进制表示形式就一目了然了）：

```rust
impl Solution {
    pub fn reverse_bits(x: u32) -> u32 {
        let mut n = x;
        n = n >> 16 | n << 16;
        n = (n & 0xff00ff00) >> 8 | (n & 0x00ff00ff) << 8;
        n = (n & 0xf0f0f0f0) >> 4 | (n & 0x0f0f0f0f) << 4;
        n = (n & 0xcccccccc) >> 2 | (n & 0x33333333) << 2;
        (n & 0xaaaaaaaa) >> 1 | (n & 0x55555555) << 1
    }
}
```

[1]: https://leetcode.cn/problems/reverse-bits/solutions/685436/dian-dao-er-jin-zhi-wei-by-leetcode-solu-yhxz/
