# 组合

## 描述

> 来源：力扣（LeetCode）
>
> 链接：<https://leetcode.cn/problems/combinations/>

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例 1：**

> **输入：** n = 4, k = 2
> **输出：**
> [
> &nbsp;&nbsp;&nbsp;&nbsp;[2,4],
> &nbsp;&nbsp;&nbsp;&nbsp;[3,4],
> &nbsp;&nbsp;&nbsp;&nbsp;[2,3],
> &nbsp;&nbsp;&nbsp;&nbsp;[1,2],
> &nbsp;&nbsp;&nbsp;&nbsp;[1,3],
> &nbsp;&nbsp;&nbsp;&nbsp;[1,4],
> ]

**示例 2：**

> **输入：** n = 1, k = 1
> **输出：** \[\[1]]

**提示：**

- `1 <= n <= 20`
- `1 <= k <= n`

## 题解

### 方法一：递归实现组合型枚举

[官方题解][1] 讲解的非常详细，这里不再重复。主要记住回朔法的经典模板：

```txt
tmp
fn dfs(curr, n) {
  // 递归退出条件
  if curr == n + 1 {
      return
  }

  // 考虑选中 curr
  tmp.push(curr);
  // 继续处理 curr + 1 -> n 的子问题
  dfs(curr + 1, n)

  // 回溯到 curr，考虑不选中 curr，直接处理 curr + 1 -> n 的子问题
  tmp.pop(curr)
  dfs(curr + 1, n)
}
```

递归退出条件根据实际决定，如果可以提前退出，就相当于剪枝。

```rust
impl Solution {
    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {
        let mut tmp = Vec::new();
        let mut ans = Vec::new();
        Self::dfs(1, n, k, &mut tmp, &mut ans);
        ans
    }

    fn dfs(curr: i32, n: i32, k: i32, tmp: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>) {
        if tmp.len() as i32 + (n - curr + 1) < k {
            return;
        }

        if tmp.len() as i32 == k {
            ans.push(tmp.clone());
            return;
        }

        tmp.push(curr);
        Self::dfs(curr + 1, n, k, tmp, ans);
        tmp.pop();
        Self::dfs(curr + 1, n, k, tmp, ans);
    }
}
```

### 方法二：非递归（字典序法）实现组合型枚举

[官方题解][1] 下面几个关键的点没有给出解释和证明，导致理解起来有点抽象：

1. 为什么规则一是规则二的特殊情况？
2. 为什么按照规则二得到的数字就是字典序中的下一个数字？
3. 为什么时间复杂度是 $O(\binom{n}{k}\times k)$？

这里将回答以上 3 个问题，作为官解的补充。同时从另一个角度并结合一个具体例子说明官解中“直接在方案上变换来得到下一个方案”算法的步骤，帮助大家更好地理解官解思路。

先来回顾一下规则一和规则二。一个二进制数字 $x$，它由 $k$ 个 1 和 $n−k$ 个 0 组成，按如下两个规则得到它字典序中的下一个数字 $next(x)$：

- 规则一：$x$ 的最低位为 1，这种情况下，如果末尾有 $t$ 个连续的 1，我们直接将倒数第 $t$ 位的 1 和倒数第 $t+1$ 位的 0 替换，就可以得到 $next(x)$。如 0011→0101，0101→0110，1001→1010，1001111→1010111。
- 规则二：$x$ 的最低位为 0，这种情况下，末尾有 $t$ 个连续的 0，而这 $t$ 个连续的 0 之前有 $m$ 个连续的 1，我们可以将倒数第 $t+m$ 位置的 1 和倒数第 $t+m+1$ 位的 0 对换，然后把倒数第 $t+1$ 位到倒数第 $t+m−1$ 位的 1 移动到最低位。如 0110→1001，1010→1100，1011100→1100011。

对于规则一中的数字，如果将其看做末尾有 **0** 个连续的 0，然后对其按规则二进行变换，其变换方式实际上和规则一完全一致。例如 1001111，按照规则二，0 个连续的 0 之前有 4 个连续的 1，将倒数第 4 位的 1 和倒数第 5 位的 0 对换，得到 1010111；接着要把倒数第 1 位到倒数第 3 位的 1 移动到最低位，但实际这些 1 已在最低位，不需要再操作。可以看到这个操作过程与规则一的操作过程完全一样，因此规则一是规则二在 $t=0$ 时的特殊情况。对任何数字，均可按照规则二统一处理来得到 $next(x)$。

接下来看问题 2，为什么按照规则二得到的数字就是字典序中的下一个数字？

$x$ 由 $k$ 个 1 和 $n−k$ 个 0 组成，可以写成 `[0,1]{n}[1]{m}[0]{t}` 这样的形式，其中 `[x,y]{z}` 表示 $z$ 个连续的 $x$ 或 $y$，$z$ 可以等于 $0$。例如 1011100，可以写为 `[0,1]{2}[1]{3}[0]{2}`。我们想要得到 $next(x)$，也就是要将 $x$ 增大，同时保证增量最小，那么我们就要从最低位开始，将某一位加 1（注意是二进制加法）。显然不能在低位的 0 处加 1，因为这会使得 1 的个数超过 $k$ 个。因此我们只能在最低位的 1 处将其加 1，`[0,1]{n}[1]{m}[0]{t}` 变为 `[0,1]{n}[1]{1}[0]{t+m-1}`，例如 1011100 在最低位的 1 处加 1 变为 1100000。但这样做之后，1 的个数减少 $m-1$ 个，需再补充 $m-1$ 个 1，同时又要保证增量最小，那么就只能在最低位补 1，也就是 `[0,1]{n}[1]{1}[0]{t+m-1}` 变为 `[0,1]{n}[1]{1}[0]{t}[1]{m-1}`，例如 1011100 先变为 1100000，最低位补 2 个 1 后变为 1100011。此变换过程的效果实际上与规则二描述的过程完全等价，因此我们按规则二得到的数字就是字典序中的下一个数字。

需要注意的一点是，`[0,1]{n}[1]{m}[0]{t}` 如果 $n=0$，上述过程无法进行。但当 $n=0$ 时，说明 $x$ 已是最大值，不需要再考虑 $next(x)$。

我们还可以将规则二等价拆分成如下 3 个步骤：

1. 从最低位开始找到第一个 `01` 模式。
2. 将 `01` 变成 `10`。
3. `01` 模式右边的 `1` 全部移到最低位。

拆成这 3 个步骤后，我们就能很好地理解官解中“直接在方案上变换来得到下一个方案”的算法。

先看第 1 步，如何找到第一个 `01` 模式。假设已得到方案 $\{a_{0}, a_{1}, \cdots , a_{k-1}\}$，例如 $\{2, 3, 5\}$（5 选 3），其对应的二进制数为 10110（注意高位对应大数字）。由于 1 表示选中，0 表示不选，可选的数字是 n 个连续的数字，因此第一个 `01` 模式表示某个数字被选中，但不选其紧邻的下一个数，反应在方案中就是 $a_{j} + 1 \neq a_{j}$。例如 $\{2, 3, 5\}$，$3 \neq 5$，3 是被选中的数字，其其紧邻的下一个数 4 未被选中。

再看第 2 步，将 `01` 变成 `10`。实际上就是进行一个反选操作，取消被选中的数，选择未被选中的数。即从方案中删除 $a_{j}$，将 $a_{j}$ 紧邻的下一个数 $a_{j} + 1$ 加入方案，也等价于将 $a_{j}$ 替换为 $a_{j} + 1$。例如 $\{2, 3, 5\}$，第 1 步中分析得知 $a_{j}=3$，因此将 3 替换成 4。

最后看第 3 步，`01` 模式右边的 `1` 全部移到最低位。假设 `01` 模式右边有 $m$ 个 1，也就是原来有 $m$ 个数被选中，全部移到最低位后，相当于选中的 $m$ 个数被重置为 1 到 m。即将方案中所有 $a_{i}, i<j$ 重置为 $i + 1$。例如 $\{2, 3, 5\}$ 经过第 2 步变为 $\{2, 4, 5\}$，再将 2 重置成 1，最终得到 $\{1, 4, 5\}$，其对应的二进制数为 11001，等于原方案对应的二进制数 10110 的字典序的下一个数。

理解了上述 3 个步骤后，就可以很自然地将这些步骤翻译为程序代码（官题中使用了哨兵技巧简化条件判断，但这只是编程的小技巧，与算法无关，为了保持直观性，这里的示例代码没有使用哨兵）：

```rust
impl Solution {
    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {
        let mut ans = Vec::new();

        // 初始方案，即二进制数最低位 k 个 1 对应的方案
        let mut tmp: Vec<i32> = (1..=k).collect();
        ans.push(tmp.clone());

        loop {
            let mut j = 0;
            // 第 1 步：从最低位开始找到第一个 `01` 模式
            while j < k as usize - 1 && tmp[j] + 1 == tmp[j + 1] {
                // 第 3 步：同时将 `01` 模式右边的 `1` 全部移到最低位
                tmp[j] = j as i32 + 1;
                j += 1;
            }

            // 已达最后一个方案，即二进制数最高位 k 个 1 对应的方案
            if tmp[j] == n as i32 {
                break;
            }

            // 第 2 步：将 `01` 变成 `10`。
            tmp[j] = tmp[j] + 1;

            ans.push(tmp.clone());
        }

        ans
    }
}
```

loop 中每一次循环对应一个方案，共有 $\binom{n}{k}$ 个方案，所以循环了 $\binom{n}{k}$ 次。每个循环内部还有一个 $k$ 次小循环，因此总的时间复杂度为 $O(\binom{n}{k}\times k)$。

[1]: https://leetcode.cn/problems/combinations/solutions/405094/zu-he-by-leetcode-solution/
