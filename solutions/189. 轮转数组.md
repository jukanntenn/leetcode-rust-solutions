# 轮转数组

## 描述

> 来源：力扣（LeetCode）
>
> 链接：<https://leetcode.cn/problems/rotate-array/>

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k`  是非负数。

**示例 1:**

> **输入:** nums = [1,2,3,4,5,6,7], k = 3  
> **输出:** [5,6,7,1,2,3,4]  
> **解释:**
> 向右轮转 1 步: [7,1,2,3,4,5,6]
> 向右轮转 2 步: [6,7,1,2,3,4,5]
> 向右轮转 3 步: [5,6,7,1,2,3,4]

**示例  2:**

> **输入：** nums = [-1,-100,3,99], k = 2  
> **输出：** [3,99,-1,-100]  
> **解释:**
> 向右轮转 1 步: [99,-1,-100,3]
> 向右轮转 2 步: [3,99,-1,-100]

**提示：**

- `1 <= nums.length <= 105`
- `-231 <= nums[i] <= 231 - 1`
- `0 <= k <= 105`

**进阶：**

- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为  `O(1)` 的  **原地** 算法解决这个问题吗？

## 题解

### 方法一：使用额外的数组

[官方题解][1] 已讲解的非常清晰。

```rust
impl Solution {
    pub fn rotate(nums: &mut Vec<i32>, k: i32) {
        let n = nums.len();
        let mut new_arr = vec![0; n];

        nums.iter()
            .enumerate()
            .for_each(|(i, num)| new_arr[(i + k as usize) % n] = *num);
        nums.clone_from_slice(&new_arr);
    }
}
```

### 方法二：环状替换

[官方题解][1] 思路总体讲解的比较清晰，但有几个点解释的不够细致，如果不能理解这几个点，就无法理解算法的正确性。

1. 为什么按照这种变换方式一定会回到原出发点？
2. 算法外层循环 $gcd(n,k)$ 次后，是否一定刚好覆盖所有元素？有没有可能遗漏元素或者同一个元素被换了两次位置？
3. 最小公倍数和最大公约数的转换关系是怎么来的？

先看第一个问题，为什么按照这种变换方式一定会回到原出发点？我们假设从位置 $i$ 出发，下一个位置是 $(i + k) \% n$，走 $m$ 步后，位置到达 $(i + mk) \% n$，$mk$ 一定可以整除 $k$，而当 $mk$ 等于 $k$ 和 $n$ 的最小公倍数时，此时 $mk$ 可以整除 $n$，这时位置等于 $i$，也就是回到了原出发点。此外还可以知道不会比这更早回到原出发点，因为如果在更早的时候回到了原出发点，那么说明存在 $m', m'<m$，$m'k$ 可整除 $n$，这和 $mk$ 是 $k$ 和 $n$ 的最小公倍数矛盾。

因为第二个问题的回答需要用到第三个问题的结论，因此我们先来说第三个问题。设 $gcd(n, k) = d$，则 $n = pd, k = qd$，且 $p, q$ 互质（因为如果不互质，就可以分离出一个公因子，那么 $d$ 就不是最大公约数了），则 $pqd$ 是 $n$ 和 $k$ 的公倍数，且还是最小公倍数，不然的话说明还有更小的公倍数 $l = p'k = p'qd = q'n = q'pd$，从而 $p'q = q'p$，又 $p, q$ 互质，所以 $p'=rp, q'=rq$，那么 $l = p'qd = q'pd = rpqd$，$r$ 最小取到 1，所以 $pqd$ 是最小公倍数。因此 $gcd(n, k) = d = \frac{pqd^2}{pqd} = \frac{nk}{lcm(n, k)}$。

回到第二个问题，根据对第一个问题的分析，$mk = lcm(n, k)$，所以 $m = lcm(n, k)/k$，也就是说出发后走 $m$ 步回到原出发点，期间经历了 $m = lcm(n, k)/k$ 个元素，算法总共循环了 $gcd(n, k)$ 次，因此总共经历了 $mgcd(n, k) = (lcm(n, k)/k)gcd(n, k) = nk/k = n$ 个元素。

虽然算法刚好遍历 $n$ 个元素，但是如果漏掉 1 个元素，同时某个元素遍历 2 遍，也是遍历 $n$ 个元素，所以还要再证明每个元素遍历且只遍历了一次。设出发位置为 $i$ 和 $i'$，$i, i' < gcd(n, k) <= k$，$i$ 遍历的位置可表示为 $(i + mk) \% n$，$i'$ 遍历的位置可表示为 $(i' + m'k) \% n$，若要遍历到同一个元素，则 $(i + mk) \% n=(i'+ m'k) \% n$，该方程无解（可以直观地理解无解，但严谨的数学证明需要用到数论同余方程的知识，这里就不再深究了），因此每次遍历的元素都不相同，所以每个元素遍历且只遍历了一次。

```rust
impl Solution {
    pub fn rotate(nums: &mut Vec<i32>, k: i32) {
        if k == 0 {
            return;
        }

        let n = nums.len();
        let cnt = Solution::gcd(n, k as usize);

        for i in 0..cnt {
            let mut curr = i;
            let mut prev = nums[curr];

            loop {
                let next = (curr + k as usize) % n;
                (nums[next], prev) = (prev, nums[next]);
                curr = next;

                if curr == i {
                    break;
                }
            }
        }
    }

    fn gcd(mut n: usize, mut m: usize) -> usize {
        assert!(n != 0 && m != 0);
        while m != 0 {
            if m < n {
                std::mem::swap(&mut m, &mut n);
            }
            m %= n;
        }
        n
    }
}
```

### 方法三：数组翻转

[官方题解][1] 给了方法但没给证明，以前做这道题都是死记硬背，这里给出正确性证明，帮助我们更好地理解算法。

根据题目要求，位置为 $i$ 的元素，需要被移动到 $(i+k)\%n$ 的位置，只要证明以算法中的方式经过多次翻转后，位置为 $i$ 的元素被移到了期望的位置，就说明算法是正确的。

由于都是翻转操作，我们先来看对于一个长度为 $n$ 的数组，沿其对称轴翻转后，索引 $i$ 对应元素的新索引是什么？翻转前，索引 $i$ 和数组最后一个元素（索引为 $n-1$）的距离为 $n-1-i$，翻转操作不会改变元素的相对位置，翻转后，索引 $n-1$ 的元素来到索引 0 的位置，因此索引 $i$ 的元素来到了与索引 0 的距离为 $n-1-i$ 的位置，也就是其索引变为 $n-1-i$。

先来看 [n-k, n-1] 区间的元素，因为这些元素经过第一次翻转后，来到 [0, k-1] 的区间，设原来的索引为 $i$，则第一次翻转后索引变为 $n - 1 - i$，第二次是翻转 [0, k-1] 的区间，带入上述翻转索引变换公式，第二次翻转后索引变为 $k-1-(n-1-i) = i+k-n = (i+k)\%n$，也就是说索引为 $i$ 的元素经过这两次翻转变换后，来到了 $(i+k)\%n$ 的位置，这正是我们期望的位置。

再来看 [0, n-k-1] 区间的元素，这些元素经过第一次翻转后，来到 [k, n-1] 的区间。第二次翻转，由于区间的起始位置不是 0，因此不能直接套用上述翻转索引变换公式。但我们可以先将区间向左平移 $k$ 个元素，翻转后再向右平移 $k$ 个元素，这和直接原地翻转是等价的。设原来的索引为 $i$，则第一次翻转后索引变为 $n - 1 - i$。第二次翻转时，先向左平移 $k$ 个元素，索引变为 $n-1-i-k$，翻转后索引变为 $n-k-1-(n-1-i-k) = i$，再向右平移 $k$ 个元素，索引变为 $i+k = (i+k)\%n$，这正是我们期望的位置。

可见，所有元素经过算法的翻转变换后，都被移动到我们期望的位置，因此算法是正确的。

```rust
impl Solution {
    pub fn rotate(nums: &mut Vec<i32>, k: i32) {
        let n = nums.len();
        let k = (k as usize) % n;
        nums[0..n].reverse();
        nums[0..k].reverse();
        nums[k..n].reverse();
    }
}
```

[1]: https://leetcode.cn/problems/rotate-array/solutions/551039/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/
