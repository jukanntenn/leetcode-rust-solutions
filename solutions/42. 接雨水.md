# 接雨水

## 描述

> 来源：力扣（LeetCode）
>
> 链接：<https://leetcode.cn/problems/trapping-rain-water/>

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![rainwatertrap](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

> **输入**：height = [0,1,0,2,1,0,1,3,2,1,2,1]  
> **输出**：6  
> **解释**：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

**示例 2：**

> **输入**：height = [4,2,0,3,2,5]  
> **输出**：9

**提示：**

- `n == height.length`
- `1 <= n <= 2 * 104`
- `0 <= height[i] <= 105`

## 题解

### 方法一：动态规划

没什么说的，[官方题解][1]讲的很清晰了。

```rust
use std::cmp::{max, min};

impl Solution {
    pub fn trap(height: Vec<i32>) -> i32 {
        let n = height.len();

        if n == 0 {
            return 0;
        };

        let mut left_max = vec![0; n];
        left_max[0] = height[0];
        for i in 1..n {
            left_max[i] = max(height[i], left_max[i - 1]);
        }

        let mut right_max = vec![0; n];
        right_max[n - 1] = height[n - 1];
        for i in (0..(n - 1)).rev() {
            right_max[i] = max(height[i], right_max[i + 1]);
        }

        let mut res = 0;
        for i in 0..n {
            res += (min(left_max[i], right_max[i]) - height[i]);
        }

        res
    }
}
```

### 方法二

[官方题解][1]引入了一个叫单调栈的名词，而且也没有解释为什么要这么做的原因，导致乍看起来很高端，不容易理解，但换一种解释就容易明白了。

实际过程是这样的，首先不断地往右边扫描，如果扫到的柱子高度比前一根要矮，那么它和前面任何一根柱子都组不了盛水的容器，继续往右扫，直到遇到比前一根要高的柱子，那么它和前两根柱子就可以组成一个盛水容器，这时候就可以计算这 3 根柱子形成容器的储水量。这还没完，这跟柱子高度如果比前前一根也要高，那么它们也能组成一个盛水容器，继续计算这个容器的储水量，但要注意这个容器包含了上一次计算过的容器，为了防止重复计算，我们可以假想上一个容器被填满了石头。直到处理完所有容器，然后继续往右扫，持续重复这个过程。

这个过程需要记录之前扫过的柱子，而且后扫的柱子先被处理，自然而然就需要用一个栈结构。而且根据前面的分析可以知道，栈中存的柱子高度是单调不增的，这就是单调栈的来历。

另外，2 根柱子肯定是无法形成可接水的容器的，所以至少得有 3 根柱子（栈中 2 根，外面 1 根）。

```rust
use std::cmp::min;

impl Solution {
    pub fn trap(height: Vec<i32>) -> i32 {
        let n = height.len();

        if n <= 2 {
            return 0;
        };

        let mut res: i32 = 0;
        let mut stack: Vec<usize> = Vec::new();

        // 不断向右扫描柱子
        for i in 0..n {
            while (!stack.is_empty() && height[i] > height[*stack.last().unwrap()]) {
                // 进入到这个循环，说明柱子 i 比前一根要高。
                // 栈中只有一根柱子，肯定组不了容器。而且它比柱子 i 要矮，不可能再作为容器的左边界（因为 i 更高，作为左边界有可能接更多雨水），所以没必要再存栈。
                let top = stack.pop().unwrap();
                if stack.is_empty() {
                    break;
                };

                let left = *stack.last().unwrap();

                let curr_width = i - left - 1;
                // height[top] 理解为上一个已计算过容器的左边界（根据之前的分析，一定低于右边界柱子 i），
                // 假想里面填满了石头，形成高度为 height[top] 底部。
                let curr_height = min(height[i], height[left]) - height[top];
                res += curr_width as i32 * curr_height;
            }

            stack.push(i);
        }

        res
    }
}
```

### 方法三

如果 `height[left] < height[right]` 这个判断条件不好理解的，可以把判断条件改为 `left_max <= right_max`，这两个条件是等价的，推导如下：

设 `i` 是左指针，`j` 是右指针，`max(m..n)` 表示从 `height[m]` 到 `height[n]` 的最大值，那么 `left_max = max(0..i)`，`right_max = max(j..n-1)`：

若 `left_max <= right_max`，那么：`left_max = max(0..i) <= right_max = max(j..n-1) <= max(i..n-1)`

`max(j..n-1) <= max(i..n-1)` 是因为局部 `(j..n-1)` 最大值肯定不大于全局 `(i..n-1)` 最大值。

亦即 `left_max = max(0..i) <= max(i, n-1)`，也就是 `left_max <= right_max` 可推出 `left_max = min(i 左边的最大值，i 右边的最大值)`。

若 `left_max >= right_max`（取不取等号不影响结论），同理可得 `right_max = min(i 左边的最大值，i 右边的最大值)`。

```rust
use std::cmp::{max, min};

impl Solution {
    pub fn trap(height: Vec<i32>) -> i32 {
        let n = height.len();

        if n <= 2 {
            return 0;
        };

        let mut i = 0;
        let mut j = n - 1;

        let mut left_max = 0;
        let mut right_max = 0;

        let mut res = 0;
        while i < j {
            left_max = max(left_max, height[i]);
            right_max = max(right_max, height[j]);

            if left_max < right_max {
                res += left_max - height[i];
                i += 1;
            } else {
                res += right_max - height[j];
                j -= 1;
            }
        }

        res
    }
}
```

[1]: https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/
