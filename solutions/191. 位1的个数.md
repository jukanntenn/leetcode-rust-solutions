# 位 1 的个数

## 描述

> 来源：力扣（LeetCode）
>
> 链接：<https://leetcode.cn/problems/number-of-1-bits/>

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中 设置位[^1] 的个数（也被称为[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F)）。

**示例 1：**

> **输入**：n = 11
> **输出**：3
> **解释**：输入的二进制串 **1011** 中，共有 3 个设置位。

**示例 2：**

> **输入**：n = 128
> **输出**：1
> **解释**：输入的二进制串 **10000000** 中，共有 1 个设置位。

**示例 3：**

> **输入**：n = 2147483645
> **输出**：30
> **解释**：输入的二进制串 **11111111111111111111111111111101** 中，共有 30 个设置位。

**提示：**

- `1 <= n <= 231 - 1`

**进阶**：

- 如果多次调用这个函数，你将如何优化你的算法？

## 题解

## 方法一：循环检查二进制位

朴素的解题思路，[官方题解][1] 讲解的非常了清晰了：

```rust
impl Solution {
    pub fn hammingWeight(n: u32) -> i32 {
        let mut n2 = n;
        let mut w = 0;
        while n2 > 0 {
            w += n2 & 1;
            n2 >>= 1;
        }

        w as i32
    }
}
```

## 方法二：位运算优化

[官方题解][1] 讲解的比较清晰，这里再进一步说明一下为什么 $n\& (n−1)$ 的运算结果恰为把 $n$ 的二进制位中的最低位的 1 变为 0 之后的结果。

使用 [77. 整数反转](./77.%20组合.md) 中符号的定义，$n$ 的二进制形式可以表示为 `[0,1]{x}1[0]{y}`，即最低位 1 后跟 $y$ 个 0。`[0,1]{x}1[0]{y}` 减去 1 的结果为 `[0,1]{x}0[1]{y}`，两个数字做 `&` 运算，结果刚好是最低位的 1 变成了 0。

```rust
impl Solution {
    pub fn hamming_weight(n: i32) -> i32 {
        let mut n2 = n;
        let mut cnt = 0;
        while n2 > 0 {
            n2 = n2 & (n2 - 1);
            cnt += 1;
        }

        cnt as i32
    }
}
```

注意时间复杂度，因为每循环一次，$n$ 至少减少一半，因此循环次数至多为 $log_2(n)$，这和 [方法一：循环检查二进制位](#方法一循环检查二进制位) 固定循环 32 次不一样。

[^1]: set bit 指在某数的二进制表示中值为 `1` 的二进制位。

[1]: https://leetcode.cn/problems/number-of-1-bits/solutions/672082/wei-1de-ge-shu-by-leetcode-solution-jnwf/
